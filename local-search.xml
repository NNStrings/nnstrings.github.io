<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2025/07/21/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/07/21/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）是一种常用的软件设计模式，目的是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。</p><span id="more"></span><p>单例模式主要分为饿汉式和懒汉式</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><ul><li>不管是否使用实例，在类加载时就创建实例</li><li>线程安全</li><li>如果从未使用这个单例对象，启动时可能会浪费资源</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-type">static</span> Singleton instance;<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;  <span class="hljs-comment">// 禁止外部实例化</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">get_instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">// 禁止拷贝和赋值</span><br>    <span class="hljs-built_in">Singleton</span>(Singleton <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-comment">// 外部初始化静态成员</span><br>Singleton Singleton::instance;<br></code></pre></td></tr></table></figure><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><ul><li>第一次使用时才创建实例，节省资源</li><li>需要考虑多线程安全问题</li></ul><p>但庆幸的是，在C++11标准中，<strong>局部静态变量</strong>在首次进入函数时才会初始化，且初始化过程是线程安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">get_instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;  <span class="hljs-comment">// 使用局部静态变量</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-built_in">Singleton</span>(Singleton <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果需要携带参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">get_instance</span><span class="hljs-params">(std::string <span class="hljs-type">const</span> &amp;path = <span class="hljs-string">&quot;&quot;</span>)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton <span class="hljs-title">instance</span><span class="hljs-params">(path)</span></span>;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有好几个构造函数，我们还可以使用类模板解决</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Singleton</span><span class="hljs-params">(std::string <span class="hljs-type">const</span> &amp;s)</span>: vi(s) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Singleton</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>: vi(i) &#123;</span>&#125;<br>    std::variant&lt;std::string, <span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">get_instance</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">static</span> Singleton <span class="hljs-title">instance</span><span class="hljs-params">(std::forward&lt;Args&gt;(args)...)</span></span>;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-built_in">Singleton</span>(Singleton <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;<br>        std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-keyword">auto</span> &amp;&amp;arg) &#123;<br>            <span class="hljs-keyword">using</span> T = std::<span class="hljs-type">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(arg)&gt;;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Strings: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Int: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>        &#125;, vi);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>⚠️ 输入参数只有第一次是有用的，之后输入的参数都是无效的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>design-pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-应用层</title>
    <link href="/2025/06/29/net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2025/06/29/net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>计算机网络知识篇之应用层详解</p><span id="more"></span><h2 id="网络应用原理"><a href="#网络应用原理" class="headerlink" title="网络应用原理"></a>网络应用原理</h2><h3 id="网络应用体系结构"><a href="#网络应用体系结构" class="headerlink" title="网络应用体系结构"></a>网络应用体系结构</h3><p>应用体系结构主要有两种主流的体系结构：客户-服务端体系结构和对等（P2P）体系结构。</p><ul><li>客户-服务端体系结构：有一个总是打开的主机，称为服务器，服务于来自其他成为客户的主机的请求</li><li>P2P体系结构：对专用服务器几乎没有依赖，应用程序在间断连接的主机对之间使用直接通信</li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进行通信的实际是进程，它们使用进程间通信机制相互通信，在两个不同端系统上的进程，通过跨越计算机网络交换报文来相互通信。在一对进程之间的通信会话场景中，发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。</p><p>从一个进程向另一个进程发送报文必须通过下面的网络，进程通过一个成为<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文。下图展现了两个经过因特网通信的进程之间的套接字通信。</p><p><img src="/images/cn-img/2/6.png"></p><p>为了标识该接收进程，需要定义主机的地址和在目的主机中指定接收进程的标识符。在因特网中，主机有IP地址标识，接收进程的标识符用端口号表示。流行的应用分配了特定的端口号，例如Web服务器使用80端口，邮件服务器进程使用25端口。</p><h3 id="可供应用程序使用的传输协议"><a href="#可供应用程序使用的传输协议" class="headerlink" title="可供应用程序使用的传输协议"></a>可供应用程序使用的传输协议</h3><p>应用程序服务要求有以下几点：可靠数据传输，吞吐量，定时和安全性。因特网为应用程序提供两个传输层协议，TCP和UDP。</p><p>TCP服务模型包括面向连接的服务和可靠的数据传输服务。</p><ul><li>面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器相互交换传输层控制信息，在握手阶段后，一个全双工（连接双方的进程可以同时进行报文的收发）的TCP连接在两个进程之间建立。当应用程序结束报文发送时，必须拆除连接。</li><li>可靠的数据传输服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。</li></ul><p>UDP是一种不提供不必要服务的轻量级传输协议，它仅提供最低限度的服务，UDP是无连接的，提供一种不可靠数据传输服务。</p><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><h3 id="域名系统概述"><a href="#域名系统概述" class="headerlink" title="域名系统概述"></a>域名系统概述</h3><p>域名系统DNS，是互联网使用的命名系统，用来把人们使用的机器名字转换为IP地址，互联网采用层次结构的命名树作为主机的名字，并使用分布式域名系统DNS，DNS使大多数名字都在本地进行解析，仅少量需要互联网上通信。</p><p>域名解析过程：当需要把主机名解析成IP地址时，应用进程调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器，本地域名服务器查找域名后，把对应的IP地址放在回答报文中返回，应用进程获得目的主机的IP地址后即可进行通信。</p><h3 id="互联网域名结构"><a href="#互联网域名结构" class="headerlink" title="互联网域名结构"></a>互联网域名结构</h3><p>互联网采用层次结构的命名树作为主机的名字，任何一个连接在互联网上的主机或路由器都有一个唯一的层次结构名字，即域名。</p><p>域名的分类：</p><ul><li>顶级域名<ul><li>国家顶级域名（cn, us等）</li><li>通用顶级域名（com, net, org, edu等）</li><li>基础结构域名（只有arpa，用于反向域名解析，又称反向域名）</li></ul></li><li>二级域名<ul><li>类别域名（ac, com, edu, gov等）</li><li>行政区域名（bj, js等）</li></ul></li></ul><p>域名空间：</p><p><img src="/images/cn-img/2/1.png"></p><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p>域名服务器分类：</p><ul><li>根域名服务器：层次最高的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址，根域名服务器是最重要的域名服务器，无论是哪个本地域名服务器要对互联网上任何一个域名进行解析，只要自己无法解析，就首先要求助于根域名服务器</li><li>顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名，当收到DNS查询请求时，就给出相应的回答</li><li>权限域名服务器：负责一个区的域名服务器，当权限域名服务器还不能给出回答时，就会告诉发出查询请求的DNS客户，下一步应找哪一个权限域名服务器</li><li>本地域名服务器：当主机发出DNS查询请求时，这个查询请求报文发给本地域名服务器</li></ul><p><img src="/images/cn-img/2/3.png"></p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>主机向本地域名服务器查询，采用递归查询：如果本地域名服务器不知道查询域名的IP，则本地域名服务器以DNS客户的身份，向其他根域名服务器发出查询请求报文，而不是让主机自己查询。</p><p>本地域名服务器向根域名服务器查询，采用迭代查询：当根域名服务器收到本地域名服务器发出的查询请求报文时，要么给出要查询的IP地址，要么告诉本地域名服务器下一步应向哪个域名服务器查询，通常是把自己知道的顶级域名服务器IP地址告诉本地域名服务器，接着本地域名服务器在向顶级域名服务器查询，顶级域名服务器查询通常是告知权限域名服务器的IP地址，本地域名服务器在向权限域名服务器查询，最后权限域名服务器把查询结果告诉本地域名服务器，最后把查询结果返回给主机。</p><p><img src="/images/cn-img/2/2.png"></p><p>为了提高DNS查询效率，并减轻根域名服务器的负荷，在域名服务器中广泛使用高速缓存，在主机本地浏览器缓存和HOST文件中，也缓存了一些域名的IP地址。</p><h2 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h2><h3 id="FTP-概述"><a href="#FTP-概述" class="headerlink" title="FTP 概述"></a>FTP 概述</h3><p>文件传输协议FTP是互联网上使用最广泛的文件传输协议，提供交互式访问，允许客户指明文件类型和格式，并允许文件具有存取权限。</p><p>基于TCP的FTP和基于UDP的简单文件传输协议TFTP，它们都是文件共享协议中的一大类，即复制整个文件，其特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后将修改后的文件副本传回原节点。</p><h3 id="FTP-的基本工作原理"><a href="#FTP-的基本工作原理" class="headerlink" title="FTP 的基本工作原理"></a>FTP 的基本工作原理</h3><p>FTP的特点：只提供文件传输的基本服务，使用TCP可靠性运输服务，FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</p><p>FTP工作流程：FTP使用客户服务器方式，一个FTP服务器进程可以同时为多个客户进程提供服务，FTP的服务进程分为两大部分：主进程，负责接受新的请求；若干从属进程，负责处理单个请求。</p><p>主进程工作步骤：</p><ul><li>打开熟知端口21，是客户进程能够连接</li><li>等待客户进程发出连接请求</li><li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可以创建一些子进程</li><li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发进行的</li></ul><p>FTP的两个TCP连接：</p><ul><li>控制连接：在整个会话期间一直打开，FTP客户发出的传送请求，通过控制连接发送给服务器端口21</li><li>数据连接：用于传输文件，端口号20</li></ul><p>由于FTP使用两个不同的端口号，所以数据连接与控制连接不会发生混乱。服务器端控制进程收到FTP客户发来的文件传输请求后，就创建数据传输进程和数据连接，用来连接客户端和服务端的数据传送进程。</p><p><img src="/images/cn-img/2/4.png"></p><h3 id="简单文件传输协议TFTP"><a href="#简单文件传输协议TFTP" class="headerlink" title="简单文件传输协议TFTP"></a>简单文件传输协议TFTP</h3><p>TFTP是很小且易于实现的文件传输协议，使用客户服务器方式，但使用UDP数据报，因此TFTP需要有自己的差错改正措施，<strong>TFTP只支持文件传输而不支持交互</strong>，TFTP没有庞大的命令集，没有列目录功能，不能对用户进行身份识别。</p><p>TFTP的优点：</p><ul><li>可用于UDP环境。例如当需要程序或文件同时向许多机器下载时就往往需要使用TFTP</li><li>TFTP代码所占的内存较小</li></ul><p>TFTP的主要特点：</p><ul><li>每次传输的数据报文中有512字节的数据，但最后一次可不足512字节</li><li>数据报文按序编号，从1开始</li><li>支持ASCII码或二进制传输</li><li>可对文件进行读或写</li><li>使用很简单的首部</li></ul><p>TFTP工作流程：TFTP客户进程发送一个请求报文给TFTP服务器进程，其熟知端口号为69。TFTP服务器进程选择一个新的端口和TFTP客户进程通信。若文件长度恰好为512字节整数倍，则文件传输完毕后，还必须在最后发送一个只含首部而无数据的数据报；若不是整数倍，则最后一个报文一定不足512字节，可作为文件结束标志。</p><h2 id="Web-和-HTTP"><a href="#Web-和-HTTP" class="headerlink" title="Web 和 HTTP"></a>Web 和 HTTP</h2><h3 id="HTTP-概述"><a href="#HTTP-概述" class="headerlink" title="HTTP 概述"></a>HTTP 概述</h3><p>Web的应用层协议是超文本传输协议（HTTP），HTTP由两个程序实现：一个客户程序和一个服务器程序，通过交换HTTP报文进行会话，HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p><p>Web浏览器实现了HTTP的客户端（例如IE，Chrome），Web服务器实现了HTTP的服务端（例如Apache），它用于存储Web对象，每个对象由url寻址。</p><p>当用户请求一个Web页面时，浏览器向服务器发出页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。HTTP使用TCP作为传输层协议，HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。</p><p><img src="/images/cn-img/2/7.png"></p><p>HTTP是一个无状态协议，因为HTTP服务器并不保存关于客户的任何信息。例如一个特定的客户连续两次请求同一个对象，服务器会重新发送该对象。</p><h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p>当这种客户-服务器的交互是经TCP进行的时，应用程序的研制者需要做一个重要的决定，即每个请求&#x2F;响应对是经过一个单独的TCP连接发送（<strong>非持续连接</strong>），还是所有响应及请求经相同的TCP连接发送（<strong>持续连接</strong>）。总体来说，持续连接节省了各种系统资源。</p><h3 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h3><p>通用首部字段：</p><ul><li>Cache-Control：用于控制缓存机制的行为</li><li>Connection：控制是否使用持久连接。close表示请求&#x2F;响应之后关闭连接，keep-alive 表示保持连接持续使用</li><li>Date：指示请求或响应的日期和时间</li><li>Transfer-Encoding：表示消息主体采用的传输编码方式</li><li>Upgrade：用于要求客户端或服务器使用不同的协议</li></ul><p>实体首部字段：</p><ul><li>Content-Type：指定实体主体的MIME类型，即告诉服务器或客户端返回的内容格式是什么（text&#x2F;html表示HTML文本，application&#x2F;json表示JSON格式数据，image&#x2F;png表示 PNG 图像）</li><li>Content-Length：指示实体主体的长度</li><li>Content-Encoding：指示实体主体使用的编码方式，如压缩格式</li><li>Content-Language：指示实体主体的自然语言</li><li>Content-Location：指示当前实体的建议位置，通常用来表示与实体相关的资源的URL</li><li>Last-Modified：表示实体最后一次修改的时间</li></ul><p><strong>HTTP请求报文：</strong></p><p>报文由ascii文本编写，每行由一个回车和换行符结束，最后一行后再附加一个回车和换行符。HTTP请求报文的第一行叫做请求行，后继的行叫做首部行。</p><p>请求行有3个字段：方法字段，url字段和HTTP版本字段。</p><p>方法字段：</p><ul><li>GET：获取资源而不修改它</li><li>POST：向服务器提交数据，通常用于提交表单或上传文件，可能会更改服务器上的资源</li><li>HEAD：获取资源的元数据（如响应头），不返回资源本身的内容</li><li>PUT：更新或创建资源</li><li>DELETE：删除资源</li></ul><p>首部行：</p><ul><li>Accept：指定客户端能够接受的响应内容类型。通常用于告诉服务器返回的内容类型，如text&#x2F;html或application&#x2F;json</li><li>Accept-Encoding：指定客户端支持的内容编码（压缩格式），如gzip、deflate等</li><li>Authorization：用于传递身份验证信息</li><li>User-Agent：表示发出请求的客户端软件信息，通常是浏览器的名称和版本</li><li>Host：指定请求的主机名和端口号</li><li>Cookie：包含发送到服务器的Cookie数据</li><li>Accept-Language：告诉服务器客户端能够接受的自然语言列表</li></ul><p>案例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/somedir/page.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.someschool.edu<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">User-agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0<br><span class="hljs-attribute">Accept-language</span><span class="hljs-punctuation">: </span>fr<br></code></pre></td></tr></table></figure><p>这个报文使用GET请求，请求对象&#x2F;somedir&#x2F;page.html，HTTP版本为HTTP&#x2F;1.1。首部行Host表明主机名称为<a href="http://www.someschool.edu(该首部行提供的信息是为了web代理高速缓存所要求的),connection/">www.someschool.edu（该首部行提供的信息是为了Web代理高速缓存所要求的），Connection</a>: close表示服务器发送完被请求对象后就关闭这条连接。User-agent指明浏览器是Mozilla&#x2F;5.0，最后Accept-language表明用户想得到对象的法语版本（如果没有该版本就获得默认版本）。</p><p>请求报文的通用格式：</p><p><img src="/images/cn-img/2/8.png"></p><p>使用GET方法时整个实体体为空，使用POST方法才使用实体体，当用户提交表单时，HTTP通常使用POST方法。当然，表单也可以使用GET方法，并在url中包括输入的数据。</p><p><strong>HTTP响应报文：</strong></p><p>响应报文有一个初始状态行，多个首部行，然后是实体体。状态行有3个字段：协议版本、状态码和相应状态信息。</p><p>状态码和相应状态信息：</p><ul><li>2XX成功：请求被正常处理了<ul><li>200 OK：客户端发来的请求在服务器端被正常处理了</li><li>204 No Content：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</li></ul></li><li>3XX重定向：浏览器需要执行某些特殊的处理以正确处理请求<ul><li>301 Moved Permanently：永久性重定向</li></ul></li><li>4XX客户端错误：客户端是发生错误的原因所在<ul><li>400 Bad Request：请求报文中存在语法错误</li><li>403 Forbidden：请求资源的访问被服务器拒绝了</li><li>404 Not Found：服务器上无法找到请求的资源</li></ul></li><li>5XX服务器错误：服务器本身发生错误<ul><li>500 Internal Server Error：服务器端在执行请求时发生了错误</li><li>503 Service Unavailable：服务器暂时处于超负载或正进行停机维护，无法处理请求</li></ul></li></ul><p>首部行：</p><ul><li>Set-Cookie：服务器用来向客户端设置Cookie</li><li>Server：指示服务器软件的名称和版本号</li></ul><p>示例：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix">HTTP<span class="hljs-symbol">/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-params">Connection:</span> close<br><span class="hljs-params">Date:</span> Tue, <span class="hljs-number">18</span> Aug <span class="hljs-number">2015</span> <span class="hljs-number">15</span>:<span class="hljs-number">44</span>:<span class="hljs-number">04</span> GMT<br><span class="hljs-params">Server:</span> Apache<span class="hljs-symbol">/2.2.3</span> (CentOS)<br><span class="hljs-params">Last-Modified:</span> Tue, <span class="hljs-number">18</span> Aug <span class="hljs-number">2015</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">03</span> GMT<br><span class="hljs-params">Content-Length:</span> <span class="hljs-number">6821</span><br><span class="hljs-params">Content-Type:</span> text<span class="hljs-symbol">/html</span><br>(data data data data data ...)<br></code></pre></td></tr></table></figure><p>服务器使用Connection: close字段告诉客户，发送完报文后将关闭该TCP连接。Date指示服务器产生并发送响应报文的日期和时间（这个时间是服务器从文件系统中检索对象，将该对象插入响应报文，并发送响应报文的时间）。Server指示服务器的类型。Last-Modified指示了该对象创建或最后修改的时间与日期。</p><p>响应报文的通用格式：</p><p><img src="/images/cn-img/2/9.png"></p><h3 id="cookie、session-和-JWT-Json-Web-Token"><a href="#cookie、session-和-JWT-Json-Web-Token" class="headerlink" title="cookie、session 和 JWT (Json Web Token)"></a>cookie、session 和 JWT (Json Web Token)</h3><p>一个Web站点希望能够识别用户，为此，HTTP使用cookie，它允许站点对用户进行跟踪。</p><p>cookie有4个组件：</p><ul><li>在HTTP响应报文中的一个cookie首部行</li><li>在HTTP请求报文中的一个cookie首部行</li><li>在用户端系统中保留的一个cookie文件，并由用户的浏览器进行管理</li><li>位于Web站点的一个后端数据库</li></ul><p>具体的流程是，当客户端第一次发送向服务器发送请求报文时，是一个普通的HTTP请求报文，发送到服务器，服务器会生成一个Session ID存储在后端的数据库中，并在将响应报文中加入Set-cookie: Session ID字段，此时，客户端会存储这个cookie信息，等到下一次在发送请求报文就会携带Cookie: Session ID字段。</p><p><img src="/images/cn-img/2/10.png"></p><p>在传统的cookie-session模式下，服务器通常需要存储Session数据，在分布式服务器中，还需要集中存储用户会话数据。JWT采用无状态的认证机制。用户每次请求时，会将已经加密的token发送到服务器，服务器验证这个token是否有效，而不需要维护会话数据。因此，服务器不需要存储状态，减少了存储负担，适合分布式架构（cookie-session模式还是主流）。</p><p>JWT 的结构由Header（头部），Payload（载荷），Signature（签名）组成，每一部分是Base64编码后的内容。</p><p>头部通常包含两部分信息：</p><ul><li>typ：标明这个是JWT，通常是 <code>JWT</code>。</li><li>alg：标明签名使用的算法，比如 <code>HS256</code>（HMAC SHA-256）或 <code>RS256</code>（RSA SHA-256）。</li></ul><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>载荷是 JWT 的主体部分，通常包含需要传递的数据。它是一个 JSON 对象，其中包含了各种声明。这些声明有三种类型：</p><ul><li>注册声明（Registered Claims）：<ul><li><code>iss</code>（Issuer）：发布者。</li><li><code>sub</code>（Subject）：主题，一般用于表示用户的ID。</li><li><code>aud</code>（Audience）：受众，表示该JWT是为哪个客户端或者服务设计的。</li><li><code>exp</code>（Expiration）：过期时间，指定JWT的有效期。</li><li><code>iat</code>（Issued At）：签发时间，表示JWT生成的时间。</li><li><code>nbf</code>（Not Before）：生效时间，JWT在这个时间之前无效。</li></ul></li><li>公共声明（Public Claims）：可以自由定义的字段，但应避免和已注册声明冲突。可以用于传递应用特定的信息。</li><li>私有声明（Private Claims）：由双方定义，通常用于传递特定信息，但这些信息不会作为标准进行共享。</li></ul><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;iat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1516239022</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>为了确保JWT在传输过程中没有被篡改，我们需要对JWT的头部和载荷进行签名。签名是通过以下方式生成的：</p><ul><li>将头部和载荷分别进行 Base64 URL 编码。</li><li>将编码后的头部和载荷用 <code>.</code> 连接起来。</li><li>使用指定的算法（如 <code>HS256</code> 或 <code>RS256</code>）和密钥对连接后的字符串进行签名。</li></ul><p>假设我们使用的是 HMAC SHA-256 算法，签名的计算方法如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">HMACSHA256(<br>  base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),<br>  secretKey<br>)<br></code></pre></td></tr></table></figure><p>将得到的三部分Base64编码用 <code>.</code> 串起来，就得到了token。</p><h3 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h3><p>Web缓冲器也叫代理服务器，它能够代表初始Web服务器来满足HTTP请求网路实体，Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。在因特网上部署Web缓存器有两个原因，首先Web缓存器可以大大减少对客户请求的响应时间，其次，Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。</p><p>因为Web缓存器保存了最近请求过的对象的副本，但对象可能是旧的，为了解决这个问题，HTTP有一种机制，允许缓存器证实它的对象是新的，这种机制就是条件GET，条件GET请求报文中包含一个If-modified-since的首部行。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS（安全超文本传输协议），是一种在HTTP基础上增加了增加了安全性的网络通信协议，它在客户端和服务器之间建立了一个加密通道，确保数据传输过程中的安全性和完整性。HTTPS的核心在于SSL（安全套接层）&#x2F;TLS（传输层安全协议）的加密技术。</p><p><img src="/images/cn-img/2/11.png"></p><p><strong>HTTPS与HTTP的主要区别：</strong></p><ul><li>安全性：HTTP是一种明文传输协议，数据在传输过程中不进行加密，容易收到中间人攻击，导致数据泄露或篡改。HTTPS在HTTP的基础上增加了SSL&#x2F;TLS加密层，所以传输数据都经过加密处理，确保了数据传输的安全性和完整性。</li><li>连接方式：HTTP使用TCP端口80通信，HTTPS使用TCP端口443进行通信。</li><li>身份验证：HTTP不提供通信双方的身份验证机制，容易遭遇伪装攻击，HTTPS通过数字证书对服务器身份进行验证，确保客户端与正确的服务器进行通信，防止钓鱼网站攻击。</li><li>性能：HTTP不涉及加密和解密过程，性能较好，HTTPS加入了加密解密，会有一定的性能开销。</li><li>部署成本：HTTP无需部署成本，可以直接使用。HTTPS需要购买SSL证书。</li></ul><p><strong>HTTPS的工作原理：</strong></p><p>首先了解一下对称加密：浏览器将加密套件列表和一个浏览器随机数发送给服务端，服务端选择一个加密套件，并也生成一个随机数，将二者返回给浏览器，然后浏览器和服务器互相确认一下。此时，浏览器和服务器将两个随机数使用加密套件生成密钥，再通过密钥进行加密的传输，保证数据的安全。（但是生成密钥的过程是明文，还是会被截获）</p><p><img src="/images/cn-img/2/12.png"></p><p>再介绍一下非对称加密：非对称加密的密钥有两把，任何一把密钥对数据进行加密，必须使用另一把密钥才能进行解密，自己不能对自己加密的数据进行解密。浏览器将加密套件列表发送给服务端，服务端选择一个加密套件，将加密套机和服务端的一个公钥返回给浏览器，然后浏览器和服务器互相确认一下。（这种方式容易受到中间人攻击，并且效率较低）</p><p><img src="/images/cn-img/2/13.png"></p><p>我们先讨论效率上的优化：</p><p>我们可以采用先使用非对称加密，再用对称加密的混合加密方式传输数据，具体流程是浏览器先向服务端发送加密套件列表，非对称加密套件列表和浏览器随机数，服务端选择加密套件并将公钥，加密套件和服务端随机数发送给浏览器，浏览器结合公钥和两个随机数生成pre-master随机数，再将加密后的pre-master随机数发送给服务端，然后浏览器和服务端通过这3个随机数创建一个新的密钥，再使用这个密钥进行对称加密。</p><p><img src="/images/cn-img/2/14.png"></p><p>为了防止中间人攻击，我们需要证书颁发机构（CA）进行第三方认证，确定我们要访问的服务器是正确的，使用CA颁发的证书，具体流程是浏览器先向服务端发送加密套件列表，非对称加密套件列表和浏览器随机数，服务端选择加密套件并将证书，加密套件和服务端随机数发送给浏览器，浏览器验证证书，并结合证书中的公钥和两个随机数生成pre-master随机数，再将加密后的pre-master随机数发送给服务端，然后浏览器和服务端通过这3个随机数创建一个新的密钥，再使用这个密钥进行对称加密。</p><p><img src="/images/cn-img/2/15.png"></p><p><strong>HTTPS性能优化：</strong></p><h3 id="HTTP-1-0-HTTP-1-1-HTTP-2-和-HTTP-3"><a href="#HTTP-1-0-HTTP-1-1-HTTP-2-和-HTTP-3" class="headerlink" title="HTTP&#x2F;1.0, HTTP&#x2F;1.1, HTTP&#x2F;2 和 HTTP&#x2F;3"></a>HTTP&#x2F;1.0, HTTP&#x2F;1.1, HTTP&#x2F;2 和 HTTP&#x2F;3</h3><p>（这里只做简单介绍）</p><p>HTTP&#x2F;1.0和HTTP&#x2F;1.1都是是基于ASCII文本的协议，相比于HTTP&#x2F;1.0，HTTP&#x2F;1.1支持长连接，从而减少因多次TCP连接带来的损失，并且支持缓存优化，使用Cathe-Control头管理缓存的使用。但存在队头阻塞的问题。</p><p>HTTP2采用二进制格式进行通信，HTTP&#x2F;2采取多路复用，允许多个请求和响应共享一个TCP连接，多个请求和响应并行发送，解决了队头阻塞的问题，HTTP&#x2F;2还使用HPACK算法对HTTP头部进行压缩，减少因重复头部信息带来的数据传输量，HTTP&#x2F;2还引入流控制机制，可以更精确的控制每个流带宽的分配，从而提高性能。</p><p>HTTP3基于QUIC协议（基于UDP），解决了TCP的许多限制，支持0-RTT连接建立，也支持多路复用，因为是基于UDP的，所以不会受到TCP连接阻塞的限制。HTTP3默认是基于TLS1.3加密的，更加安全。</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="电子邮件概述"><a href="#电子邮件概述" class="headerlink" title="电子邮件概述"></a>电子邮件概述</h3><p>电子邮件是互联网上使用最多的和最受欢迎的一种应用。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以在自己使用的邮件服务器中进行读取。</p><p>电子邮件的两个最重要的标准是<strong>简单邮件传输协议SMTP</strong>和<strong>互联网文本报文格式</strong></p><p>由于SMTP只能传输可打印的7为ASCII码邮件，后又提出<strong>通用互联网邮件扩充MIME</strong>，MIME在其邮件首部中说明了邮件的数据类型（如文本、声音、图像等）。</p><p>一个电子邮件系统应具有三个主要组成构件，就是用户代理、邮件服务器、邮件发送协议（如SMTP）和邮件读取协议（如POP3）。</p><p><img src="/images/cn-img/2/5.png"></p><h3 id="简单邮件传输协议-SMTP"><a href="#简单邮件传输协议-SMTP" class="headerlink" title="简单邮件传输协议 SMTP"></a>简单邮件传输协议 SMTP</h3><p>SMTP通信的三个阶段：</p><ul><li>连接建立：发件人的邮件发送到发送方邮件服务器的邮件缓存后，SMTP客户就每隔一定的时间对邮件缓存扫描一次，如果发现邮件，就用SMTP熟知的端口号25与接收方邮件服务器的SMTP服务器建立TCP连接（SMTP不使用中间的邮件服务器，TCP连接总是在发送方和接收方这两个邮件服务器之间进行之间连接）。</li><li>邮件传送：从MAIL命令开始，MAIL命令后面有发件人的地址。下面跟着一个或多个RCPT命令，取决于把同一个邮件发送给一个或多个收件人。在下面是DATA命令，表示要开始传送邮件的内容了。</li><li>连接释放：邮件发送完毕后发送QUIT命令，SMTP服务器返回服务关闭的信息，表示SMTP同意释放TCP连接，邮件传送过程结束。</li></ul><h3 id="邮件读取协议-POP3-和-IMAP"><a href="#邮件读取协议-POP3-和-IMAP" class="headerlink" title="邮件读取协议 POP3 和 IMAP"></a>邮件读取协议 POP3 和 IMAP</h3><p>POP3使用客户服务器的工作方式，在接收邮件的计算机中用户代理必须运行POP3客户程序，而在收件人所连接的ISP的邮件服务器中则运行POP3服务器程序。</p><p>POP3协议的一个特点就是只要用户从POP3服务器读取了邮件，POP3服务器就把该邮件删除，但这是不方便的，后来POP3进行了扩充，让用户可以实现设置邮件读取后在POP3服务器中存放的时间。</p><p>IMAP协议比POP3复杂的多，它也使用客户服务器的工作方式，在使用IMAP时，在用户计算机运行IMAP客户程序，然后与接收方的邮件服务器上的IMAP服务器程序建立TCP连接。用户可以在自己的计算机上操纵邮件服务器的邮箱，因此IMAP是一个联机协议。当用户计算机上的IMAP客户程序打开IMAP服务器的邮箱时，用户就可以看到邮件的首部。若用户打开某个邮件，则该邮件才传到用户的计算机上。在用户未发出删除邮件的命令之前，IMAP服务器邮箱中的邮件一直保存着。此外，IMAP还允许收件人只读取邮件的某一个部分（例如读取一个带有视频附件的邮件）。</p><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p>用户在浏览器中浏览各种信息需要使用HTTP协议，因此在浏览器和互联网上的邮件服务器之间传送邮件时，仍使用HTTP协议，但在各邮件服务器之间传送邮件时，仍使用SMTP协议。</p>]]></content>
    
    
    <categories>
      
      <category>net</category>
      
    </categories>
    
    
    <tags>
      
      <tag>net</tag>
      
      <tag>计算机网络知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-概述</title>
    <link href="/2025/06/29/net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0/"/>
    <url>/2025/06/29/net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>计算机网络知识篇之概述</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OSI参考模型与TCP&#x2F;IP参考模型:</p><table>    <tr>        <td>OSI七层模型</td>        <td>TCP/IP模型</td>        <td>功能</td>        <td>TCP/IP协议族</td>    </tr>    <tr>        <td>应用层</td>        <td rowspan="3">应用层</td>        <td>直接向计算机用户提供接口和服务，完成用户希望完成的各种网路操作</td>        <td>HTTP, FTP, TFTP, DNS, Telnet, SMTP</td>    </tr>    <tr>        <td>表示层</td>        <td>进行数据编解码，数据加解密和格式转换</td>        <td>没有协议</td>    </tr>    <tr>        <td>会话层</td>        <td>管理（建立、维护、重连）通信会话，组织和协调两个会话进程之间的通信，并对数据交换进行管理</td>        <td>没有协议</td>    </tr>    <tr>        <td>传输层</td>        <td>传输层</td>        <td>向两台主机中进程之间的通信提供通用的数据传输服务，<b>实现端到端连接</b></td>        <td>TCP, UDP</td>    </tr>    <tr>        <td>网络层</td>        <td>网络层</td>        <td>为分组交换网上的不同主机提供通信服务，也就是进行IP选址和路由选择</td>        <td>IP, ICMP, RIP, IGMP</td>    </tr>    <tr>        <td>数据链路层</td>        <td>数据链路层</td>        <td>在物理层提供的比特流基础上，通过差错控制，流量控制的方法，将由差错的物理线路变为无差错、能可靠传输数据帧的数据链路</td>        <td>SLIP, CSLIP, PPP, ARP, RARP</td>    </tr>    <tr>        <td>物理层</td>        <td>物理层</td>        <td>利用传输介质为数据链路提供物理连接，实现相邻计算机节点之间比特流的透明传输</td>        <td>IEEE802.1 A, IEEE802.2到IEEE802.11</td>    </tr></table><p>不同网络层次之间，数据进行不断的传递，不同网络层次之间数据传递的单位是协议数据单元（PDU），从应用层到物理层，应用层是消息和报文（Message），传输层中，TCP是数据段（Segment），UDP是数据报（Datagram），网络层是分组，数据包（Packet），数据链路层是数据帧（Frame），物理层是比特流（Bit）。</p><p>PDU在网络通信中有非常重要的作用，其功能主要有：</p><ul><li>数据的封装和解封装：每一层在发送数据时，上层数据作为负载进行封装，并添加该层特定的头部信息，在接收数据时，逐层解封装，去掉各层头部信息，还原上层数据。</li><li>协议操作与控制：PDU头部包含协议信息，如源地址、目的地址、序列号、确认号等，保证数据的正确传输和控制。</li><li>错误检测与纠正：添加校验码等信息，网络层和链路层能够检测并纠正传输错误，提高传输的可靠性。</li></ul><h2 id="主要参考文献"><a href="#主要参考文献" class="headerlink" title="主要参考文献"></a>主要参考文献</h2><ul><li>计算机网络：自顶向下方法（原书第8版）</li><li>TCP-IP详解卷1：协议</li><li>TCP-IP详解卷2：实现</li><li>图解HTTP</li><li>图解TCPIP</li><li>大量个人博客、知乎、bilibili等</li></ul>]]></content>
    
    
    <categories>
      
      <category>net</category>
      
    </categories>
    
    
    <tags>
      
      <tag>net</tag>
      
      <tag>计算机网络知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变参函数</title>
    <link href="/2025/06/29/cpp/%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0/"/>
    <url>/2025/06/29/cpp/%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>尽量不要C风格变参函数，现代C++提供了更安全、更强大的替代方案（变参模板等），但在特定场景下仍有存在价值。</p><span id="more"></span><p>在无法给出所有传递给函数的参数的类型和数目时，可以使用省略号（…）指定函数参数表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span> a ...)</span></span>;<br></code></pre></td></tr></table></figure><p>最具代表性的变长参数函数：<code>printf</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>要讲变长参数，就不得不先提一下几个宏，<code>va_list</code>，<code>va_start</code>，<code>va_arg</code>，<code>va_end</code>。</p><p>具体的使用方法就是先定义一个 <code>va_list</code> 类型的变量，变量是指向参数的指针，使用 <code>va_start</code> 初始化刚定义的变量，<code>va_arg</code> 返回变长参数的值，<code>va_end</code> 将定义的变量重置为 NULL。下面的这个例子实现了计算几个数的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    va_list ap;     <span class="hljs-comment">// 定义一个 va_list 类型的变量</span><br>    <span class="hljs-built_in">va_start</span>(ap, count);     <span class="hljs-comment">// va_start 初始化刚定义的变量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>        res += <span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>); <span class="hljs-comment">// va_arg 返回变长参数的值</span><br>    <span class="hljs-built_in">va_end</span>(ap);     <span class="hljs-comment">// va_end 将定义的变量重置为 NULL</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺便再提一句，还有一个宏 <code>va_copy</code>，它的作用是将一个 <code>va_list</code> 拷贝到另一个 <code>va_list</code> 中，具体用法是 <code>va_copy(dest, src);</code>，当我们可能要不止一次用到参数时，我们就会使用它，例如，分别计算参数的均值和方差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sample_stddev</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> </span>&#123;<br>    <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br>    va_list args1;<br>    <span class="hljs-built_in">va_start</span>(args1, count);<br>    va_list args2;<br>    <span class="hljs-built_in">va_copy</span>(args2, args1);    <span class="hljs-comment">// 拷贝一次参数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>        <span class="hljs-type">double</span> num = <span class="hljs-built_in">va_arg</span>(args1, <span class="hljs-type">double</span>);<br>        sum += num;<br>    &#125;<br>    <span class="hljs-built_in">va_end</span>(args1);<br>    <span class="hljs-type">double</span> mean = sum / count;    <span class="hljs-comment">// 计算均值</span><br> <br>    <span class="hljs-type">double</span> sum_sq_diff = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>        <span class="hljs-type">double</span> num = <span class="hljs-built_in">va_arg</span>(args2, <span class="hljs-type">double</span>);<br>        sum_sq_diff += (num-mean) * (num-mean);<br>    &#125;<br>    <span class="hljs-built_in">va_end</span>(args2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(sum_sq_diff / count);   <span class="hljs-comment">// 计算方差</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在现代的gcc编译器中，上述的宏由gcc自带的内建函数定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> __builtin_va_list va_list;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_start(v,l)__builtin_va_start(v,l)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_end(v)__builtin_va_end(v)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_arg(v,l)__builtin_va_arg(v,l)</span><br></code></pre></td></tr></table></figure><p>实际上，原理很简单，<code>va_list</code> 是一个字符指针，<code>va_start</code> 确定初始参数的下一个参数，<code>va_arg</code> 确定当前参数的下一个参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *va_list;<br><br><span class="hljs-comment">// 向上取整</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __va_rounded_size(TYPE)  \</span><br><span class="hljs-meta">  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</span><br><br><span class="hljs-comment">// 确定初始参数下一个参数的位置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_start(AP, LASTARG) \</span><br><span class="hljs-meta"> (AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))</span><br><br><span class="hljs-comment">// 确定这个参数的下一个参数的位置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_arg(AP, TYPE)\</span><br><span class="hljs-meta"> (AP += __va_rounded_size (TYPE),\</span><br><span class="hljs-meta">  *((TYPE *) (AP - __va_rounded_size (TYPE))))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake 基础</title>
    <link href="/2025/06/28/cmake/cmake%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/06/28/cmake/cmake%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>cmake基础知识，包括内置变量、常见命令、生成器表达式、命令行参数等。</p><span id="more"></span><h2 id="cmake-常见内置变量"><a href="#cmake-常见内置变量" class="headerlink" title="cmake 常见内置变量"></a>cmake 常见内置变量</h2><h3 id="构建目录和工作目录"><a href="#构建目录和工作目录" class="headerlink" title="构建目录和工作目录"></a>构建目录和工作目录</h3><ul><li>CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, &lt;projectname&gt;_BINARY_DIR: 构建目录</li><li>CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, &lt;projectname&gt;_SOURCE_DIR: 项目工作目录</li><li>CMAKE_CURRENT_SOURCE_DIR: 当前处理的 CMakeLists.txt 所在的路径</li><li>CMAKE_CURRENT_LIST_FILE: 当前处理的 CMakeLists.txt 的完整路径</li><li>CMAKE_CURRENT_LIST_LINE: 输出这个变量所在的行</li></ul><h3 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h3><ul><li>PROJECT_NAME: 返回通过 <code>project</code> 指令定义的项目名称</li><li>PROJECT_IS_TOP_LEVEL: 项目是否是顶层目录</li></ul><h3 id="构建类型"><a href="#构建类型" class="headerlink" title="构建类型"></a>构建类型</h3><ul><li>CMAKE_BUILD_TYPE: 单一配置生成器（Makefile, Ninja）的构建类型，主要就是 <code>Debug</code> 和 <code>Release</code></li><li>CMAKE_CONFIGURATION_TYPES: 多配置生成器（Visual Studio, Xcode, Ninja Multi-Config）的构建类型，主要就是 <code>Debug</code> 和 <code>Release</code></li></ul><h3 id="C-编译选项"><a href="#C-编译选项" class="headerlink" title="C++ 编译选项"></a>C++ 编译选项</h3><ul><li>CMAKE_CXX_STANDARD: 指定要使用的 C++ 标准版本（ 98, 11, 14, 17, 20）</li><li>CMAKE_CXX_STANDARD_REQUIRED: 指定是否必须使用指定的 C++ 标准版本。如果设置为 ON，并且编译器不支持指定的标准版本，CMake 将报错并停止配置过程</li><li>CMAKE_CXX_EXTENSIONS: 是否启用编译器扩展</li></ul><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><ul><li>CMAKE_SYSTEM_NAME: CMake 要构建的操作系统的名称（例如 Android, DOS, Linux, OpenBSD, Windows）</li><li>CMAKE_&lt;LANG&gt;_COMPILER_ID: 编译器的名称（例如 GNU, Clang, MSVC）</li></ul><h2 id="cmake-常见命令"><a href="#cmake-常见命令" class="headerlink" title="cmake 常见命令"></a>cmake 常见命令</h2><h3 id="cmake-minimum-required-命令"><a href="#cmake-minimum-required-命令" class="headerlink" title="cmake_minimum_required 命令"></a>cmake_minimum_required 命令</h3><p>定义 CMake 的最低或最低和最高兼容版本范围。</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION &lt;min&gt;[...&lt;policy_max&gt;] [FATAL_ERROR])<br></code></pre></td></tr></table></figure><h3 id="message-命令"><a href="#message-命令" class="headerlink" title="message 命令"></a>message 命令</h3><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>([&lt;mode&gt;] <span class="hljs-string">&quot;message to display&quot;</span> ...)<br></code></pre></td></tr></table></figure><p>其中，mode 是可选的，可以指定消息的类型。常见的消息类型包括：</p><ul><li>STATUS：非重要消息，通常用于显示一般信息。</li><li>WARNING：警告消息，CMake 会继续执行。</li><li>AUTHOR_WARNING：开发者警告，CMake 会继续执行。</li><li>SEND_ERROR：错误消息，CMake 会继续执行但会跳过生成步骤。</li><li>FATAL_ERROR：致命错误消息，CMake 会终止所有处理过程。</li></ul><p>其中，字符串信息可以包含变量信息。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;CMAKE_SOURCE_DIR: $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="include-命令"><a href="#include-命令" class="headerlink" title="include 命令"></a>include 命令</h3><p>用于加载并执行指定的 CMake 脚本文件中的命令，如果希望在找不到指定文件时 CMake 不报错，而是继续执行，可以使用 <code>OPTIONAL</code> 关键字。</p><p>语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">include</span>(path/to/your/file1.cmake)<br><span class="hljs-keyword">include</span>(OPTIONAL path/to/your/file2.cmake)<br></code></pre></td></tr></table></figure><h3 id="file-命令"><a href="#file-命令" class="headerlink" title="file 命令"></a>file 命令</h3><p>文件操作命令，此命令专用于需要访问文件系统的文件和路径操作。</p><p>将文件 filename 读到变量 variable 中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(READ &lt;filename&gt; &lt;variable&gt; [OFFSET &lt;offset&gt;] [LIMIT &lt;limit&gt;] [HEX])<br><span class="hljs-keyword">file</span>(READ <span class="hljs-string">&quot;README.md&quot;</span> README_CONTENT)<br></code></pre></td></tr></table></figure><p>将内容 content 写入文件 filename</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(WRITE &lt;filename&gt; &lt;content&gt;...)<br><span class="hljs-keyword">file</span>(WRITE <span class="hljs-string">&quot;output.txt&quot;</span> <span class="hljs-string">&quot;Hello, CMake!&quot;</span>)<br></code></pre></td></tr></table></figure><p>生成与 globbing-expressions 匹配的文件列表并将其存储到 variable 中，globbing-expressions 与正则表达式类似，但更简单</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB &lt;variable&gt; [LIST_DIRECTORIES <span class="hljs-keyword">true</span>|<span class="hljs-keyword">false</span>] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] &lt;globbing-expressions&gt;...)<br><span class="hljs-keyword">file</span>(GLOB_RECURSE &lt;variable&gt; [FOLLOW_SYMLINKS] [LIST_DIRECTORIES <span class="hljs-keyword">true</span>|<span class="hljs-keyword">false</span>] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] &lt;globbing-expressions&gt;...)<br></code></pre></td></tr></table></figure><p>如果指定了 RELATIVE 标志，则结果将作为给定路径的相对路径返回，如果 LIST_DIRECTORIES 设置为 false，则结果中会省略目录。</p><p>GLOB_RECURSE 模式将遍历匹配目录的所有子目录并匹配文件，默认情况下，GLOB_RECURSE 会从结果列表中省略目录。</p><h3 id="set-命令"><a href="#set-命令" class="headerlink" title="set 命令"></a>set 命令</h3><p><code>set</code> 命令用于设置变量的值。它可以用来定义普通的变量、缓存变量（即保存在 CMakeCache.txt 文件中的变量）以及目标属性等。</p><p><strong>设置普通变量：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE])<br></code></pre></td></tr></table></figure><p>&lt;variable&gt; 是要设置的变量名，&lt;value&gt;… 是变量的值，可以是一个或多个值，[PARENT_SCOPE] 可以将变量加到父目录。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(MY_VARIABLE <span class="hljs-string">&quot;hello, cmake!&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;MY_VAR: $&#123;MY_VARIABLE&#125;&quot;</span>)<br><span class="hljs-keyword">set</span>(MY_LIST <span class="hljs-string">&quot;item1&quot;</span> <span class="hljs-string">&quot;item2&quot;</span> <span class="hljs-string">&quot;item3&quot;</span>)<br><span class="hljs-keyword">foreach</span>(item IN LISTS MY_LIST)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;List item: $&#123;item&#125;&quot;</span>)<br><span class="hljs-keyword">endforeach</span>()<br></code></pre></td></tr></table></figure><p><strong>设置缓存变量：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])<br></code></pre></td></tr></table></figure><p>&lt;variable&gt; 是要设置的变量名，&lt;value&gt;… 是变量的值，可以是一个或多个值，&lt;type&gt; 是变量的类型，&lt;docstring&gt; 是描述信息，[FORCE] 是强制覆盖现有的缓存值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Release&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;Choose Release or Debug&quot;</span> FORCE)<br></code></pre></td></tr></table></figure><h3 id="option-命令"><a href="#option-命令" class="headerlink" title="option 命令"></a>option 命令</h3><p>提供一个用户可以选择性选择的布尔选项。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">option</span>(&lt;variable&gt; <span class="hljs-string">&quot;&lt;help_text&gt;&quot;</span> [value])<br></code></pre></td></tr></table></figure><p>&lt;value&gt; 如果没有提供初始值 ，则布尔值 <code>OFF</code> 是默认值。如果 &lt;variable&gt; 已设置为正常或缓存变量，则该命令不执行任何操作。</p><h3 id="find-package-命令"><a href="#find-package-命令" class="headerlink" title="find_package 命令"></a>find_package 命令</h3><p><code>find_package</code> 用于查找和加载外部库或模块。它可以帮助你自动发现并配置项目依赖的第三方库，从而简化项目的配置过程。</p><p><code>find_package</code> 工作机制：</p><ul><li>查找配置文件：cmake 首先尝试查找包的配置文件（如 <code>Find&lt;PackageName&gt;.cmake</code> 或 <code>&lt;PackageName&gt;Config.cmake</code>）</li><li>加载配置文件：找到配置文件后，cmake 会加载该文件，并根据其中的定义设置相应的变量和目标</li><li>设置变量和目标：配置文件通常会设置一些变量（如 <code>$&#123;PackageName&#125;_FOUND</code>），并导入目标（如 <code>target_link_libraries</code>）</li></ul><p>基本语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [REQUIRED] [[COMPONENTS] [components...]])<br></code></pre></td></tr></table></figure><p>其中，&lt;PackageName&gt; 为要查找的包名称，[version] 是指定所需的版本号，[EXACT] 表示如果指定了版本号，则要求版本必须完全匹配，[QUIET] 表示如果找不到包，不输出错误信息，[REQUIRED] 表示如果找不到包，则中止配置过程并显示错误信息，[[COMPONENTS] [components…]] 指包的特定组件。</p><p>下面举一些常用的 C++ 库</p><p>使用线程库 Threads</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(Threads REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC Threads::Threads)<br></code></pre></td></tr></table></figure><p>使用并行库 TBB</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(TBB REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)<br></code></pre></td></tr></table></figure><p>使用 Boost 库中的 <code>filesystem</code> 和 <code>system</code> 组件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(Boost <span class="hljs-number">1.65</span> REQUIRED COMPONENTS filesystem system)<br><span class="hljs-keyword">target_link_libraries</span>(main Boost::Boost Boost::filesystem Boost::system)<br></code></pre></td></tr></table></figure><p>使用线性代数库 Eigen3</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(Eigen3 REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main Eigen3::Eigen)<br></code></pre></td></tr></table></figure><p>使用 opencv</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(OpenCV <span class="hljs-number">4.5</span> REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;OpenCV_LIBS&#125;</span>)<br></code></pre></td></tr></table></figure><p>使用压缩库 zlib</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(ZLIB REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main ZLIB::ZLIB)<br></code></pre></td></tr></table></figure><p>使用 Qt5</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(Qt5 COMPONENTS Core Widgets REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main Qt5::Core Qt5::Widgets)<br></code></pre></td></tr></table></figure><p>使用加密库 openssl</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(OpenSSL REQUIRED)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;OPENSSL_INCLUDE_DIR&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(MyExecutable <span class="hljs-variable">$&#123;OPENSSL_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="list-命令"><a href="#list-命令" class="headerlink" title="list 命令"></a>list 命令</h3><p><code>list</code> 命令用于操作字符串列表。它提供了一系列子命令来创建、修改和查询列表中的元素。</p><ul><li>APPEND：追加元素</li><li>INSERT：插入元素</li><li>REMOVE_ITEM：移除指定元素</li><li>REMOVE_AT：按索引移除元素</li><li>REMOVE_DUPLICATES：移除重复元素</li><li>LENGTH：获取列表长度</li><li>GET：获取指定索引处的元素</li><li>FIND：查找元素的索引</li><li>JOIN：连接列表元素为字符串</li><li>SUBLIST：提取子列表</li><li>REVERSE：反转列表</li><li>SORT：对列表进行排序</li></ul><p>追加一个新文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(SOURCE_FILES <span class="hljs-string">&quot;main.cpp&quot;</span> <span class="hljs-string">&quot;helper.cpp&quot;</span> <span class="hljs-string">&quot;utils.cpp&quot;</span>)<br><span class="hljs-keyword">list</span>(APPEND SOURCE_FILES <span class="hljs-string">&quot;new_feature.cpp&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="add-library-命令"><a href="#add-library-命令" class="headerlink" title="add_library 命令"></a>add_library 命令</h3><p><code>add_library</code> 是用于定义库目标（library target）的关键命令。通过 add_library，可以创建静态库、共享库（动态库）、模块库或接口库，并将源文件编译成这些库。</p><p>基本语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE | INTERFACE] [EXCLUDE_FROM_ALL] &lt;sources&gt;...)<br></code></pre></td></tr></table></figure><p>其中，&lt;name&gt; 是库的目标名称，[STATIC | SHARED | MODULE | INTERFACE] 指定库的类型（可选，默认为静态库），[EXCLUDE_FROM_ALL] 可以将该库从所有构建目标中排除（可选），&lt;sources&gt; 是库的源文件列表。</p><ul><li>静态库（STATIC）：通常以 <code>.a</code> 或 <code>.lib</code> 为扩展名。它包含了编译后的对象文件，这些对象文件在链接时直接复制到目标可执行文件中。</li><li>共享库（SHARED）：通常以 <code>.so</code>、<code>.dll</code> 或 <code>.dylib</code> 为扩展名。它包含了编译后的代码，在运行时被加载，而不是直接包含在最终的可执行文件中。</li><li>模块库（MODULE）：模块库也是一种共享库，但它通常是被设计为插件或模块化系统的一部分。它与共享库类似，但更侧重于动态加载，且不需要遵循标准的共享库接口。</li><li>接口库（INTERFACE）：通常用于定义库的接口、编译选项、包含目录、链接的库等，并且可以被其他目标引用。</li></ul><p>静态库&#x2F;共享库例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">project/<br>│── CMakeLists.txt<br>│── main.cpp<br>│── <span class="hljs-built_in">math</span>/<br>│   │── CMakeLists.txt<br>│   │── <span class="hljs-built_in">math</span>.h<br>│   │── <span class="hljs-built_in">math</span>.cpp<br></code></pre></td></tr></table></figure><p>math&#x2F;CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(<span class="hljs-keyword">math</span> STATIC/SHARED <span class="hljs-keyword">math</span>.cpp)<br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-keyword">math</span> PUBLIC <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)<br></code></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<br><span class="hljs-keyword">project</span>(StaticLibExample)<br><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-keyword">math</span>)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main PRIVATE <span class="hljs-keyword">math</span>)<br></code></pre></td></tr></table></figure><p>模块库例子见 <code>module-example</code> 文件夹。</p><p>该命令还可以为 <code>&lt;target&gt;</code> 命名，命名为 <code>&lt;name&gt;</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(&lt;name&gt; ALIAS &lt;<span class="hljs-keyword">target</span>&gt;)<br></code></pre></td></tr></table></figure><h3 id="target-compile-definitions-命令"><a href="#target-compile-definitions-命令" class="headerlink" title="target_compile_definitions 命令"></a>target_compile_definitions 命令</h3><p><code>target_compile_definitions</code> 用于为目标添加编译定义（compile definitions）的命令（可以直接理解成为目标添加宏定义）。</p><p>基本语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(&lt;<span class="hljs-keyword">target</span>&gt;<br>  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]<br>  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;target&gt;</code> 为目标名称（可以是库、可执行文件等）。<code>PRIVATE</code> 表示仅应用于当前目标。<code>PUBLIC</code> 表示应用于当前目标及其依赖的目标。<code>INTERFACE</code> 仅应用于依赖于当前目标的其他目标（适用于接口库）。<code>&lt;definition&gt;</code>：要添加的编译定义，格式为 <code>NAME</code> 或 <code>NAME=value</code>。</p><p>属性可以作用一个或多个变量，每个变量前都可以添加属性</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># TEST 和 NDEBUG 都是 PRIVATE 属性的</span><br><span class="hljs-keyword">target_compile_definitions</span>(main PRIVATE <span class="hljs-keyword">TEST</span> NDEBUG)<br><span class="hljs-comment"># TEST 是 PRIVATE 属性的，NDEBUG 是 PUBLIC 属性的</span><br><span class="hljs-keyword">target_compile_definitions</span>(main PRIVATE <span class="hljs-keyword">TEST</span> PUBLIC NDEBUG)<br></code></pre></td></tr></table></figure><h3 id="target-compile-options-命令"><a href="#target-compile-options-命令" class="headerlink" title="target_compile_options 命令"></a>target_compile_options 命令</h3><p><code>target_compile_options</code> 用于为目标添加编译器选项。通过这个命令可以在构建过程中为特定的目标（如可执行文件、库等）设置编译器标志和选项。这些选项会在编译该目标时传递给编译器，从而控制代码的编译行为。</p><p>基本语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_options</span>(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE]<br>  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]<br>  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])<br></code></pre></td></tr></table></figure><p><code>[BEFORE]</code> 是可选参数，表示将选项插入到现有选项列表的前面（默认情况下会追加到末尾）。</p><p>例如我们现在要开启所有警告并将警告视为错误，并要求在 Linux 和 Windows 上都有效。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_options</span>(main PUBLIC $&lt;$&lt;PLATFORM_ID:Windows&gt;:/W4 /WX&gt;<br>                                   $&lt;$&lt;PLATFORM_ID:Linux&gt;:-Wall -Werror)<br></code></pre></td></tr></table></figure><h3 id="target-include-directories-命令"><a href="#target-include-directories-命令" class="headerlink" title="target_include_directories 命令"></a>target_include_directories 命令</h3><p><code>target_include_directories</code> 用于为目标指定包含目录（include directories）的命令。通过这个命令可以告诉编译器在编译特定目标时应该搜索哪些目录以查找头文件。</p><p>基本语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE] [SYSTEM] [INTERFACE | PUBLIC | PRIVATE] &lt;directory&gt; ...)<br></code></pre></td></tr></table></figure><p>其中，<code>[BEFORE]</code> 为可选参数，表示将目录插入到现有目录列表的前面（默认情况下会追加到末尾）。<br><code>[SYSTEM]</code> 为可选参数，表示这些目录是系统目录，某些编译器会对这些目录中的警告进行特殊处理。</p><p>添加公共的包含目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(MyLibrary STATIC src/library.cpp)<br><span class="hljs-keyword">target_include_directories</span>(MyLibrary PUBLIC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><p>针对不同的构建类型（如 Debug 或 Release）设置不同的包含目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(MyExecutable PRIVATE<br>    $&lt;$&lt;CONFIG:Debug&gt;:<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/debug/<span class="hljs-keyword">include</span>&gt;<br>    $&lt;$&lt;CONFIG:Release&gt;:<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/release/<span class="hljs-keyword">include</span>&gt;<br>)<br></code></pre></td></tr></table></figure><h3 id="target-link-libraries-命令"><a href="#target-link-libraries-命令" class="headerlink" title="target_link_libraries 命令"></a>target_link_libraries 命令</h3><p><code>target_link_libraries</code> 用于为目标指定链接库的关键命令。通过该命令，你可以告诉编译器在构建目标（如可执行文件或库）时需要链接哪些库。这使得项目能够正确地引用外部依赖项或内部模块。</p><p>基本语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(&lt;<span class="hljs-keyword">target</span>&gt; [BEFORE] [PRIVATE|PUBLIC|INTERFACE] &lt;library&gt;...&gt;)<br></code></pre></td></tr></table></figure><p>链接单个库和链接多个库：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(MyExecutable main.cpp)<br><br><span class="hljs-keyword">add_library</span>(MyLibrary STATIC library.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(MyExecutable PRIVATE MyLibrary)<br><br><span class="hljs-keyword">add_library</span>(MyLibraryA STATIC libraryA.cpp)<br><span class="hljs-keyword">add_library</span>(MyLibraryB STATIC libraryB.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(MyExecutable PRIVATE MyLibraryA MyLibraryB)<br></code></pre></td></tr></table></figure><p>链接导出集：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(MyExecutable PRIVATE MyLibrary::MyLibrary)<br></code></pre></td></tr></table></figure><h3 id="target-precompile-headers-命令"><a href="#target-precompile-headers-命令" class="headerlink" title="target_precompile_headers 命令"></a>target_precompile_headers 命令</h3><h3 id="configure-file-命令"><a href="#configure-file-命令" class="headerlink" title="configure_file 命令"></a>configure_file 命令</h3><p><code>configure_file</code> 用于生成配置文件的命令。它允许你将模板文件中的内容根据 CMake 变量的值进行替换，并生成目标文件。这在构建系统中非常有用，尤其是在需要生成配置头文件（如 config.h）或脚本文件时。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">configure_file</span>(&lt;input&gt; &lt;output&gt; [&lt;permissions&gt;]<br>               [COPYONLY]<br>               [ESCAPE_QUOTES]<br>               [@ONLY]<br>               [NEWLINE_STYLE [UNIX|DOS|WIN32|CRLF|LF]])<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>&lt;input&gt;</code>：输入文件路径（通常是模板文件）。</li><li><code>&lt;output&gt;</code>：输出文件路径（生成的目标文件）。</li><li><code>COPYONLY</code>：如果指定此选项，则不进行变量替换，直接复制文件。</li><li><code>ESCAPE_QUOTES</code>：转义模板文件中的双引号（”），以防止它们被 CMake 解析为字符串分隔符。</li><li><code>@ONLY</code>：仅替换以 @VAR@ 形式定义的变量，忽略 ${VAR} 形式的变量。</li><li><code>NEWLINE_STYLE</code>：指定输出文件的换行风格，支持以下值：<ul><li>UNIX 或 LF：使用 Unix 风格的换行符（\n）。</li><li>DOS 或 WIN32 或 CRLF：使用 Windows 风格的换行符（\r\n）。</li></ul></li></ul><p>生成配置头文件 <code>config.h</code>，其中包含一些编译时的配置信息。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(ENABLE_FEATURE_X <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(VERSION_MAJOR <span class="hljs-number">1</span>)<br><span class="hljs-keyword">set</span>(VERSION_MINOR <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">configure_file</span>(<br>    <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/config.h.in<br>    <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/config.h<br>)<br><br><span class="hljs-keyword">target_include_directories</span>(MyExecutable PRIVATE <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// config.h.in</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION_MAJOR @VERSION_MAJOR@</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION_MINOR @VERSION_MINOR@</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> @ENABLE_FEATURE_X@</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FEATURE_X_ENABLED 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FEATURE_X_ENABLED 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// config.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION_MAJOR 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION_MINOR 0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FEATURE_X_ENABLED 1</span><br></code></pre></td></tr></table></figure><h3 id="install-命令"><a href="#install-命令" class="headerlink" title="install 命令"></a>install 命令</h3><p><code>install</code> 命令是 CMake 中用于指定安装规则的关键命令。<code>install</code> 命令可以定义哪些文件和目标需要在构建完成后被复制到指定的安装目录中。这使得项目可以方便地进行打包、部署和分发。</p><p>基本语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(TARGETS &lt;<span class="hljs-keyword">target</span>&gt;... [...])<br><span class="hljs-keyword">install</span>(DIRECTORY &lt;dir&gt;... [...])<br><span class="hljs-keyword">install</span>(FILES &lt;<span class="hljs-keyword">file</span>&gt;... [...])<br><span class="hljs-keyword">install</span>(PROGRAMS &lt;<span class="hljs-keyword">file</span>&gt;... [...])<br><span class="hljs-keyword">install</span>(<span class="hljs-keyword">EXPORT</span> &lt;<span class="hljs-keyword">export</span>-name&gt; [...])<br><span class="hljs-keyword">install</span>(CODE &lt;code&gt;)<br><span class="hljs-keyword">install</span>(RUNTIME_DEPENDENCY_SET &lt;setName&gt; [...])<br></code></pre></td></tr></table></figure><p><strong>安装目标（TARGETS）</strong></p><p><code>install(TARGETS ...)</code> 用于指定将哪些构建目标（如可执行文件、库等）安装到指定位置。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(TARGETS targets... [<span class="hljs-keyword">EXPORT</span> &lt;<span class="hljs-keyword">export</span>-name&gt;]<br>        RUNTIME DESTINATION &lt;dir&gt;<br>        LIBRARY DESTINATION &lt;dir&gt;<br>        ARCHIVE DESTINATION &lt;dir&gt;<br>        PRIVATE_HEADER DESTINATION &lt;dir&gt;<br>        PUBLIC_HEADER DESTINATION &lt;dir&gt;<br>        RESOURCE DESTINATION &lt;dir&gt;<br>        INCLUDES DESTINATION &lt;dir&gt;<br>        COMPONENT &lt;component&gt;<br>        [PERMISSIONS permissions...]<br>        [CONFIGURATIONS [Debug|Release|...]]<br>        [OPTIONAL]<br>        [NAMELINK_COMPONENT &lt;component&gt;]<br>        [NAMELINK_ONLY | NO_NAMELINK])<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>TARGETS targets...</code>：要安装的目标列表。</li><li><code>EXPORT &lt;export-name&gt;</code>：指定导出集名称，用于生成配置文件。</li><li><code>RUNTIME DESTINATION &lt;dir&gt;</code>：指定运行时文件（如可执行文件）的安装目录。</li><li><code>LIBRARY DESTINATION &lt;dir&gt;</code>：指定共享库文件的安装目录。</li><li><code>ARCHIVE DESTINATION &lt;dir&gt;</code>：指定静态库文件的安装目录。</li><li><code>PRIVATE_HEADER DESTINATION &lt;dir&gt;</code>：指定私有头文件的安装目录。</li><li><code>PUBLIC_HEADER DESTINATION &lt;dir&gt;</code>：指定公有头文件的安装目录。</li><li><code>RESOURCE DESTINATION &lt;dir&gt;</code>：指定资源文件的安装目录。</li><li><code>INCLUDES DESTINATION &lt;dir&gt;</code>：指定包含文件的安装目录。</li><li><code>COMPONENT &lt;component&gt;</code>：指定组件名称，用于组件化的安装。</li><li><code>PERMISSIONS permissions...</code>：指定安装文件的权限。</li><li><code>CONFIGURATIONS [Debug|Release|...]</code>：指定适用的构建配置。</li><li><code>OPTIONAL</code>：如果目标不存在，不会导致安装失败。</li><li><code>NAMELINK_COMPONENT &lt;component&gt;</code>：指定符号链接的组件。</li><li><code>NAMELINK_ONLY | NO_NAMELINK</code>：控制符号链接的安装行为。</li></ul><p>示例：将一个静态库和可执行程序安装到指定的目录。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(MyLibrary STATIC src/library.cpp)<br><span class="hljs-keyword">add_executable</span>(MyExecutable main.cpp)<br><br><span class="hljs-keyword">install</span>(TARGETS MyLibrary MyExecutable<br>    <span class="hljs-keyword">EXPORT</span> MyProjectConfig<br>    RUNTIME DESTINATION bin<br>    LIBRARY DESTINATION lib<br>    ARCHIVE DESTINATION lib<br>)<br></code></pre></td></tr></table></figure><p><strong>安装目录（DIRECTORY）</strong></p><p><code>install(DIRECTORY ...)</code> 用于指定将整个目录及其内容安装到指定位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(DIRECTORY dirs... DESTINATION &lt;dir&gt;<br>        [FILE_PERMISSIONS permissions...]<br>        [DIRECTORY_PERMISSIONS permissions...]<br>        [USE_SOURCE_PERMISSIONS]<br>        [OPTIONAL]<br>        [MESSAGE_NEVER]<br>        [REGEX &lt;regex&gt; EXCLUDE]<br>        [REGEX &lt;regex&gt; <span class="hljs-keyword">INCLUDE</span>]<br>        [COMPONENT &lt;component&gt;]<br>        [FILES_MATCHING] [PATTERN &lt;pattern&gt; ...])<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>DIRECTORY dirs...</code>：要安装的目录列表。</li><li><code>DESTINATION &lt;dir&gt;</code>：指定安装目录。</li><li><code>FILE_PERMISSIONS permissions...</code>：指定文件的权限。</li><li><code>DIRECTORY_PERMISSIONS permissions...</code>：指定目录的权限。</li><li><code>USE_SOURCE_PERMISSIONS</code>：使用源目录中的权限设置。</li><li><code>OPTIONAL</code>：如果目录不存在，不会导致安装失败。</li><li><code>MESSAGE_NEVER</code>：禁止显示安装消息。</li><li><code>REGEX &lt;regex&gt; EXCLUDE</code>：排除匹配正则表达式的文件或目录。</li><li><code>REGEX &lt;regex&gt; INCLUDE</code>：仅包括匹配正则表达式的文件或目录。</li><li><code>COMPONENT &lt;component&gt;</code>：指定组件名称。</li><li><code>FILES_MATCHING</code>：仅匹配文件。</li><li><code>PATTERN &lt;pattern&gt; ...</code>：指定文件模式。</li></ul><p>示例：安装 <code>include</code> 目录，并排除 <code>fmt/bundled</code> 目录，再根据特定变量添加 <code>fmt/bundled</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(DIRECTORY <span class="hljs-keyword">include</span>/ <br>        DESTINATION <span class="hljs-string">&quot;$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;</span> <br>        PATTERN <span class="hljs-string">&quot;fmt/bundled&quot;</span> EXCLUDE)<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> SPDLOG_USE_STD_FORMAT <span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> SPDLOG_FMT_EXTERNAL <span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> SPDLOG_FMT_EXTERNAL_HO)<br>    <span class="hljs-keyword">install</span>(DIRECTORY <span class="hljs-keyword">include</span>/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>/fmt/bundled/<br>            DESTINATION <span class="hljs-string">&quot;$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;/$&#123;PROJECT_NAME&#125;/fmt/bundled/&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p><strong>安装文件（FILES）</strong></p><p><code>install(FILES ...)</code> 用于指定将特定文件安装到指定位置。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(FILES files... DESTINATION &lt;dir&gt;<br>        [FILE_PERMISSIONS permissions...]<br>        [DIRECTORY_PERMISSIONS permissions...]<br>        [USE_SOURCE_PERMISSIONS]<br>        [OPTIONAL]<br>        [MESSAGE_NEVER]<br>        [COMPONENT &lt;component&gt;])<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>FILES files...</code>：要安装的文件列表。</li><li><code>DESTINATION &lt;dir&gt;</code>：指定安装目录。</li><li><code>FILE_PERMISSIONS permissions...</code>：指定文件的权限。</li><li><code>DIRECTORY_PERMISSIONS permissions...</code>：指定目录的权限。</li><li><code>USE_SOURCE_PERMISSIONS</code>：使用源文件中的权限设置。</li><li><code>OPTIONAL</code>：如果文件不存在，不会导致安装失败。</li><li><code>MESSAGE_NEVER</code>：禁止显示安装消息。</li><li><code>COMPONENT &lt;component&gt;</code>：指定组件名称。</li></ul><p>示例：安装 pkg_config 文件到指定目录。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(pkg_config <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;PROJECT_NAME&#125;.pc&quot;</span>)<br><span class="hljs-keyword">set</span>(pkgconfig_install_dir <span class="hljs-string">&quot;$&#123;CMAKE_INSTALL_LIBDIR&#125;/pkgconfig&quot;</span>)<br><span class="hljs-keyword">configure_file</span>(<span class="hljs-string">&quot;cmake/$&#123;PROJECT_NAME&#125;.pc.in&quot;</span> <span class="hljs-string">&quot;$&#123;pkg_config&#125;&quot;</span> @ONLY)<br><span class="hljs-keyword">install</span>(FILES <span class="hljs-string">&quot;$&#123;pkg_config&#125;&quot;</span> DESTINATION <span class="hljs-string">&quot;$&#123;pkgconfig_install_dir&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>安装导出集（EXPORT）</strong></p><p><code>install(EXPORT ...)</code> 用于生成并安装目标导出集，通常用于生成配置文件以便其他项目使用该库。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">install</span>(<span class="hljs-keyword">EXPORT</span> &lt;<span class="hljs-keyword">export</span>-name&gt; DESTINATION &lt;dir&gt;<br>        [NAMESPACE &lt;namespace&gt;]<br>        [<span class="hljs-keyword">FILE</span> &lt;name&gt;.cmake]<br>        [EXPORT_LINK_INTERFACE_LIBRARIES]<br>        [COMPONENT &lt;component&gt;])<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>EXPORT &lt;export-name&gt;</code>：导出集名称。</li><li><code>DESTINATION &lt;dir&gt;</code>：指定安装目录。</li><li><code>NAMESPACE &lt;namespace&gt;</code>：指定命名空间前缀。</li><li><code>FILE &lt;name&gt;.cmake</code>：指定生成的配置文件名。</li><li><code>EXPORT_LINK_INTERFACE_LIBRARIES</code>：导出链接接口库。</li><li><code>COMPONENT &lt;component&gt;</code>：指定组件名称。</li></ul><p>安装目标导出集：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(config_targets_file <span class="hljs-string">&quot;spdlogConfigTargets.cmake&quot;</span>)<br><span class="hljs-keyword">set</span>(export_dest_dir <span class="hljs-string">&quot;$&#123;CMAKE_INSTALL_LIBDIR&#125;/cmake/spdlog&quot;</span>)<br><span class="hljs-keyword">install</span>(<span class="hljs-keyword">EXPORT</span> spdlog DESTINATION <span class="hljs-variable">$&#123;export_dest_dir&#125;</span> NAMESPACE spdlog:: <span class="hljs-keyword">FILE</span> <span class="hljs-variable">$&#123;config_targets_file&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="cmake-生成器表达式"><a href="#cmake-生成器表达式" class="headerlink" title="cmake 生成器表达式"></a>cmake 生成器表达式</h2><p>CMake 生成器表达式是一种用于在生成构建系统文件时进行条件判断和值替换的机制。它们允许你在配置阶段动态地指定编译选项、链接库、包含路径等，从而增强构建系统的灵活性和适应性。生成器表达式通常以 <code>$&lt;...&gt;</code> 的形式出现，并且可以在 <code>target_compile_definitions</code>、<code>target_include_directories</code>、<code>target_link_libraries</code> 等命令中使用。生成器表达式的值会在构建系统生成时被解析，而不是在 CMake 配置阶段。</p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>将字符串转换为 0 或 1。以下情况计算结果为 0：当字符串为空，不区分大小写等于 0、FALSE、OFF、N、NO、IGNORE 或 NOTFOUND，或字符串以后缀 -NOTFOUND（区分大小写）结尾。其他情况等于 1。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$&lt;BOOL:<span class="hljs-keyword">string</span>&gt;<br></code></pre></td></tr></table></figure><p>如果条件为 1，则计算结果为 <code>true_string</code>，如果条件计算结果为 0，则计算结果为空字符串。条件的任何其他值都会导致错误。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$&lt;condition:true_string&gt;<br></code></pre></td></tr></table></figure><p>如果条件为 1，则计算结果为 <code>true_string</code>，如果条件计算结果为 0，则计算结果为 <code>false_string</code>。条件的任何其他值都会导致错误。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$&lt;<span class="hljs-keyword">IF</span>:condition,true_string,false_string&gt;<br></code></pre></td></tr></table></figure><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>这里的 <code>conditions</code> 是一系列条件，AND、OR 和 NOT 就是简单的逻辑谓词</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$&lt;<span class="hljs-keyword">AND</span>:conditions&gt;<br>$&lt;<span class="hljs-keyword">OR</span>:conditions&gt;<br>$&lt;<span class="hljs-keyword">NOT</span>:condition&gt;<br></code></pre></td></tr></table></figure><h3 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h3><p>字符串或者数值相等时结果为 1，否则结果为 0。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$&lt;<span class="hljs-keyword">STREQUAL</span>:string1,string2&gt;<br>$&lt;<span class="hljs-keyword">EQUAL</span>:value1,value2&gt;<br></code></pre></td></tr></table></figure><h3 id="配置表达式"><a href="#配置表达式" class="headerlink" title="配置表达式"></a>配置表达式</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$&lt;CONFIG&gt;<br></code></pre></td></tr></table></figure><p>根据当前构建配置（如 Debug、Release 等）返回不同的值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_MODE&gt;)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC $&lt;$&lt;CONFIG:Release&gt;:RELEASE_MODE&gt;)<br></code></pre></td></tr></table></figure><h3 id="工具链和语言表达式"><a href="#工具链和语言表达式" class="headerlink" title="工具链和语言表达式"></a>工具链和语言表达式</h3><p>平台 ID（操作系统 ID），其中，platform_ids 为 CMAKE_SYSTEM_NAME 变量的值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$&lt;PLATFORM_ID:platform_ids&gt;<br></code></pre></td></tr></table></figure><p>根据平台 ID 返回不同的值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(main PRIVATE $&lt;$&lt;PLATFORM_ID:Windows&gt;:WINDOWS_PLATFORM&gt;)<br><span class="hljs-keyword">target_compile_definitions</span>(main PRIVATE $&lt;$&lt;PLATFORM_ID:Linux&gt;:LINUX_PLATFORM&gt;)<br></code></pre></td></tr></table></figure><p>C++ 编译器 ID，其值为 <code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code> 变量的值。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$&lt;CXX_COMPILER_ID&gt;<br>$&lt;COMPILE_LANGUAGE:languages&gt;<br></code></pre></td></tr></table></figure><p>如果 C++ 编译器是 MSVC 且编译的语言不是 CUDA，那么就开启 <code>/wd4251</code> 和 <code>/wd4275</code> 编译选项。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_options</span>(main PUBLIC $&lt;$&lt;<span class="hljs-keyword">AND</span>:$&lt;CXX_COMPILER_ID:MSVC&gt;<br>    $&lt;<span class="hljs-keyword">NOT</span>:$&lt;COMPILE_LANGUAGE:CUDA&gt;&gt;&gt;:/wd4251 /wd4275&gt;)<br></code></pre></td></tr></table></figure><h2 id="cmake-模块"><a href="#cmake-模块" class="headerlink" title="cmake 模块"></a>cmake 模块</h2><h3 id="GNUInstallDirs-模块"><a href="#GNUInstallDirs-模块" class="headerlink" title="GNUInstallDirs 模块"></a>GNUInstallDirs 模块</h3><p>定义 GNU 标准安装目录，提供由 GNU 编码标准定义的安装目录变量。</p><p>常用变量：</p><ul><li>CMAKE_INSTALL_&lt;dir&gt;</li><li>CMAKE_INSTALL_FULL_&lt;dir&gt;</li></ul><p>其中，<code>&lt;dir&gt;</code> 是以下的其中之一：</p><ul><li>BINDIR: 用户可执行文件 (bin)</li><li>SBINDIR: 系统管理员可执行文件 (sbin)</li><li>LIBEXECDIR: 程序可执行文件 (libexec)</li><li>SYSCONFDIR: 只读单机数据 (etc)</li><li>SHAREDSTATEDIR: 可修改的独立于架构的数据 (com)</li><li>LOCALSTATEDIR: 可修改的单机数据 (var)</li><li>RUNSTATEDIR: 运行时变量数据 (LOCALSTATEDIR&#x2F;run)</li><li>LIBDIR: 目标代码库 (lib 或 lib64)</li><li>INCLUDEDIR: C 头文件 (include)</li><li>OLDINCLUDEDIR: 非 gcc 的 C 头文件 (&#x2F;usr&#x2F;include)</li><li>DATAROOTDIR: 只读独立于架构的数据根目录 (share)</li><li>DATADIR: 只读独立于架构的数据 (DATAROOTDIR)</li><li>INFODIR: 信息文档 (DATAROOTDIR&#x2F;info)</li><li>LOCALEDIR: 语言环境相关数据 (DATAROOTDIR&#x2F;locale)</li><li>MANDIR: man 文档 (DATAROOTDIR&#x2F;man)</li><li>DOCDIR: 文档根目录 (DATAROOTDIR&#x2F;doc&#x2F;PROJECT_NAME)</li></ul><h2 id="cmake-命令行"><a href="#cmake-命令行" class="headerlink" title="cmake 命令行"></a>cmake 命令行</h2><h3 id="–system-information"><a href="#–system-information" class="headerlink" title="–system-information"></a>–system-information</h3><p>–system-information，它可以生成一个包含系统信息和 CMake 默认配置的文本文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake --system-information system_info.txt<br></code></pre></td></tr></table></figure><h3 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h3><p>要构建的 CMake 项目的根目录路径</p><h3 id="B"><a href="#B" class="headerlink" title="-B"></a>-B</h3><p>设置构建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake [&lt;options&gt;] -B &lt;path-to-build&gt; [-S &lt;path-to-source&gt;]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -S . -B build<br></code></pre></td></tr></table></figure><h3 id="G"><a href="#G" class="headerlink" title="-G"></a>-G</h3><p>设置生成器，指定使用的生成器（如 Makefile, Ninja, Visual Studio 等）。不同的生成器会生成不同类型的构建系统文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -G <span class="hljs-string">&quot;Unix Makefiles&quot;</span> ..<br>cmake -G Ninja ..<br>cmake -G <span class="hljs-string">&quot;Visual Studio 16 2019&quot;</span> ..<br></code></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="-D"></a>-D</h3><p>设置缓存变量的值。这可以用于设置编译选项、启用&#x2F;禁用特性等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -D CMAKE_BUILD_TYPE=Release -S . -B build<br>cmake -D ENABLE_TESTS=ON ..<br></code></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="-E"></a>-E</h3><p>CMake 通过签名提供内置命令行工具</p><p><strong>remove_directory &lt;dir&gt;</strong>: 删除 &lt;dir&gt; 目录及其内容。如果目录不存在，则会被默默忽略。请改用 <code>rm</code>（已弃用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -E remove_directory build<br></code></pre></td></tr></table></figure><p><strong>rm [-rRf] [–] &lt;file|dir&gt;</strong>: 删除文件 &lt;file&gt; 或目录 &lt;dir&gt;。使用 <code>-r</code> 或 <code>-R</code> 递归删除目录及其内容。如果任何列出的文件&#x2F;目录不存在，该命令将返回非零退出代码，但不记录任何消息。<code>-f</code> 选项强制删除，不提示确认，如果文件不存在也不报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -E <span class="hljs-built_in">rm</span> -r -f build<br></code></pre></td></tr></table></figure><h3 id="t-–target"><a href="#t-–target" class="headerlink" title="-t &#x2F; –target"></a>-t &#x2F; –target</h3><p>构建 <code>&lt;target&gt;</code> 而不是默认目标。可以指定多个目标，以空格分隔。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mainlib <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><span class="hljs-keyword">target_include_directories</span>(mainlib PUBLIC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-keyword">add_library</span>(testlib EXCLUDE_FROM_ALL <span class="hljs-variable">$&#123;TEST_SRC_LIST&#125;</span>)<br><span class="hljs-keyword">target_include_directories</span>(testlib PRIVATE <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">test</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-keyword">target_link_libraries</span>(testlib PRIVATE mainlib)<br><br><span class="hljs-keyword">add_executable</span>(runtests <span class="hljs-keyword">test</span>/run_tests.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(runtests PRIVATE testlib)<br></code></pre></td></tr></table></figure><p><code>testlib</code> 被标记为 <code>EXCLUDE_FROM_ALL</code>，默认不会构建这个库，但可以通过显式地指定目标来构建测试库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -S . -B build --target runtests<br></code></pre></td></tr></table></figure><h3 id="–build"><a href="#–build" class="headerlink" title="–build"></a>–build</h3><p>构建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake --build build<br></code></pre></td></tr></table></figure><h3 id="j"><a href="#j" class="headerlink" title="-j"></a>-j</h3><p>指定构建项目的线程数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake --build build -j4<br></code></pre></td></tr></table></figure><h2 id="cmake-小技巧"><a href="#cmake-小技巧" class="headerlink" title="cmake 小技巧"></a>cmake 小技巧</h2><blockquote><p>判断项目是主项目还是作为一个子模块被其他项目引用</p></blockquote><p>我们判断一下 cmake 当前目录和项目的源码目录是否相等，如果相等，则该项目是主项目，否则为子模块。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DEFINED</span> XXX_MASTER_PROJECT)<br>    <span class="hljs-keyword">if</span>(CMAKE_CURRENT_SOURCE_DIR <span class="hljs-keyword">STREQUAL</span> CMAKE_SOURCE_DIR)<br>        <span class="hljs-keyword">set</span>(XXX_MASTER_PROJECT <span class="hljs-keyword">ON</span>)<br>    <span class="hljs-keyword">else</span>()<br>        <span class="hljs-keyword">set</span>(XXX_MASTER_PROJECT <span class="hljs-keyword">OFF</span>)<br>    <span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>当然，在 CMake &gt;&#x3D; 3.21 中，我们应该使用 <code>PROJECT_IS_TOP_LEVEL</code> 来代替自定义逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>cmake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/06/28/hello-world/"/>
    <url>/2025/06/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>欢迎使用 <a href="https://hexo.io/">Hexo</a>！这是您的第一篇博文。更多信息，请参阅 <a href="https://hexo.io/docs/">文档</a>。如果您在使用 Hexo 时遇到任何问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html">故障排除</a> 中找到答案，或者您也可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a> 上向我提问。</p><span id="more"></span><h2 id="快点端上来罢"><a href="#快点端上来罢" class="headerlink" title="快点端上来罢"></a>快点端上来罢</h2><h3 id="创建一个新文章"><a href="#创建一个新文章" class="headerlink" title="创建一个新文章"></a>创建一个新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>详细信息: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br>$ hexo s<br></code></pre></td></tr></table></figure><p>详细信息: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="清除生成文件"><a href="#清除生成文件" class="headerlink" title="清除生成文件"></a>清除生成文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo cl<br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br>$ hexo g<br></code></pre></td></tr></table></figure><p>详细信息: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="远程部署站点"><a href="#远程部署站点" class="headerlink" title="远程部署站点"></a>远程部署站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br>$ hexo d<br></code></pre></td></tr></table></figure><p>详细信息: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>start</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
